diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/Makefile mp4-new/Makefile
--- mp4/Makefile	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/Makefile	2025-05-22 19:20:12.301343600 +0800
@@ -56,7 +56,7 @@
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 
-CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb
+CFLAGS = -Wall -O -fno-omit-frame-pointer -ggdb
 CFLAGS += -DSOL_UTIL
 CFLAGS += -MD
 CFLAGS += -mcmodel=medany
@@ -102,7 +102,7 @@
 	$(CC) $(CFLAGS) -c -o $U/usys.o $U/usys.S
 
 mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h
-	gcc -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c
+	gcc -Wall -I. -o mkfs/mkfs mkfs/mkfs.c
 
 # Prevent deletion of intermediate files, e.g. cat.o, after first build, so
 # that disk image changes after first build are persistent until clean.  More
@@ -133,6 +133,7 @@
 	$U/_mp4_2_mirror_test\
 	$U/_mp4_2_disk_failure_test\
 	$U/_mp4_2_write_failure_test\
+	$U/_chmod\
 	
 
 fs.img: mkfs/mkfs README $(UEXTRA) $(UPROGS)
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/kernel/bio.c mp4-new/kernel/bio.c
--- mp4/kernel/bio.c	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/kernel/bio.c	2025-05-22 19:20:12.605338000 +0800
@@ -1,17 +1,4 @@
-// Buffer cache.
-//
-// The buffer cache is a linked list of buf structures holding
-// cached copies of disk block contents.  Caching disk blocks
-// in memory reduces the number of disk reads and also provides
-// a synchronization point for disk blocks used by multiple processes.
-//
-// Interface:
-// * To get a buffer for a particular disk block, call bread.
-// * After changing buffer data, call bwrite to write it to disk.
-// * When done with the buffer, call brelse.
-// * Do not use the buffer after calling brelse.
-// * Only one process at a time can use a buffer,
-//     so do not keep them longer than necessary.
+
 
 #include "types.h"
 #include "param.h"
@@ -22,7 +9,6 @@
 #include "fs.h"
 #include "buf.h"
 
-// Added: global variable added
 extern int force_read_error_pbn;
 extern int force_disk_fail_id;
 
@@ -31,9 +17,6 @@
     struct spinlock lock;
     struct buf buf[NBUF];
 
-    // Linked list of all buffers, through prev/next.
-    // Sorted by how recently the buffer was used.
-    // head.next is most recent, head.prev is least.
     struct buf head;
 } bcache;
 
@@ -43,7 +26,6 @@
 
     initlock(&bcache.lock, "bcache");
 
-    // Create linked list of buffers
     bcache.head.prev = &bcache.head;
     bcache.head.next = &bcache.head;
     for (b = bcache.buf; b < bcache.buf + NBUF; b++)
@@ -56,16 +38,12 @@
     }
 }
 
-// Look through buffer cache for block on device dev.
-// If not found, allocate a buffer.
-// In either case, return locked buffer.
 struct buf *bget(uint dev, uint blockno)
 {
     struct buf *b;
 
     acquire(&bcache.lock);
 
-    // Is the block already cached?
     for (b = bcache.head.next; b != &bcache.head; b = b->next)
     {
         if (b->dev == dev && b->blockno == blockno)
@@ -77,8 +55,6 @@
         }
     }
 
-    // Not cached.
-    // Recycle the least recently used (LRU) unused buffer.
     for (b = bcache.head.prev; b != &bcache.head; b = b->prev)
     {
         if (b->refcnt == 0)
@@ -95,44 +71,91 @@
     panic("bget: no buffers");
 }
 
-// TODO: RAID 1 simulation
-// Return a locked buf with the contents of the indicated block.
 struct buf *bread(uint dev, uint blockno)
 {
     struct buf *b;
-    // Added: Flag used in fallback_test (Don't modify their name!!)
-    int is_forced_fail_target = 0;
-    int fail_disk = -1;
-    
-    fail_disk = force_disk_fail_id;
+    int fail_disk = force_disk_fail_id;
+    int is_pbn0_block_fail =
+        (force_read_error_pbn == blockno && force_read_error_pbn != -1);
+
     b = bget(dev, blockno);
 
-    // Force cache miss if simulation error
-    if ((b->blockno == force_read_error_pbn && force_read_error_pbn != -1) ||
-        (fail_disk != -1))
-    {
-        is_forced_fail_target = 1;
-    }
+    int need_fallback = (fail_disk == 0) || is_pbn0_block_fail;
 
-    if (!b->valid || is_forced_fail_target)
+    if (!b->valid || need_fallback)
     {
-        virtio_disk_rw(b, 0);
+        int original_blockno = b->blockno;
+        if (need_fallback)
+        {
+
+            b->blockno = blockno + DISK1_START_BLOCK;
+            virtio_disk_rw(b, 0);
+            b->blockno = original_blockno;
+        }
+        else
+        {
+
+            b->blockno = blockno;
+            virtio_disk_rw(b, 0);
+        }
         b->valid = 1;
     }
     return b;
 }
 
-// TODO: RAID 1 simulation
-// Write b's contents to disk.  Must be locked.
 void bwrite(struct buf *b)
 {
     if (!holdingsleep(&b->lock))
         panic("bwrite");
-    virtio_disk_rw(b, 1);
+
+    int pbn0 = b->blockno;
+    int pbn1 = b->blockno + DISK1_START_BLOCK;
+
+    int sim_disk_fail = force_disk_fail_id;
+    int sim_pbn0_block_fail =
+        (force_read_error_pbn == pbn0 && force_read_error_pbn != -1);
+
+    printf(
+        "BW_DIAG: PBN0=%d, PBN1=%d, sim_disk_fail=%d, sim_pbn0_block_fail=%d\n",
+        pbn0, pbn1, sim_disk_fail, sim_pbn0_block_fail);
+
+    int original_blockno = b->blockno;
+
+    if (sim_disk_fail == 0)
+    {
+        printf(
+            "BW_ACTION: SKIP_PBN0 (PBN %d) due to simulated Disk 0 failure.\n",
+            pbn0);
+    }
+    else if (sim_pbn0_block_fail)
+    {
+        printf("BW_ACTION: SKIP_PBN0 (PBN %d) due to simulated PBN0 block "
+               "failure.\n",
+               pbn0);
+    }
+    else
+    {
+        printf("BW_ACTION: ATTEMPT_PBN0 (PBN %d).\n", pbn0);
+        b->blockno = pbn0;
+        virtio_disk_rw(b, 1);
+    }
+
+    if (sim_disk_fail == 1)
+    {
+        printf(
+            "BW_ACTION: SKIP_PBN1 (PBN %d) due to simulated Disk 1 failure.\n",
+            pbn1);
+    }
+    else
+    {
+        printf("BW_ACTION: ATTEMPT_PBN1 (PBN %d).\n", pbn1);
+        b->blockno = pbn1;
+        virtio_disk_rw(b, 1);
+    }
+
+    b->blockno = original_blockno;
 }
 
-// Release a locked buffer.
-// Move to the head of the most-recently-used list.
 void brelse(struct buf *b)
 {
     if (!holdingsleep(&b->lock))
@@ -144,7 +167,7 @@
     b->refcnt--;
     if (b->refcnt == 0)
     {
-        // no one is waiting for it.
+
         b->next->prev = b->prev;
         b->prev->next = b->next;
         b->next = bcache.head.next;
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/kernel/fs.c mp4-new/kernel/fs.c
--- mp4/kernel/fs.c	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/kernel/fs.c	2025-05-22 19:20:12.447529000 +0800
@@ -1,13 +1,4 @@
-// File system implementation.  Five layers:
-//   + Blocks: allocator for raw disk blocks.
-//   + Log: crash recovery for multi-step updates.
-//   + Files: inode allocator, reading, writing, metadata.
-//   + Directories: inode with special contents (list of other inodes!)
-//   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
-//
-// This file contains the low-level file system manipulation
-// routines.  The (higher-level) system call implementations
-// are in sysfile.c.
+
 
 #include "types.h"
 #include "riscv.h"
@@ -22,11 +13,9 @@
 #include "file.h"
 
 #define min(a, b) ((a) < (b) ? (a) : (b))
-// there should be one superblock per disk device, but we run with
-// only one device
+
 struct superblock sb;
 
-// Read the super block.
 static void readsb(int dev, struct superblock *sb)
 {
     struct buf *bp;
@@ -36,7 +25,6 @@
     brelse(bp);
 }
 
-// Init fs
 void fsinit(int dev)
 {
     readsb(dev, &sb);
@@ -45,7 +33,6 @@
     initlog(dev, &sb);
 }
 
-// Zero a block.
 static void bzero(int dev, int bno)
 {
     struct buf *bp;
@@ -56,9 +43,6 @@
     brelse(bp);
 }
 
-// Blocks.
-
-// Allocate a zeroed disk block.
 static uint balloc(uint dev)
 {
     int b, bi, m;
@@ -72,8 +56,8 @@
         {
             m = 1 << (bi % 8);
             if ((bp->data[bi / 8] & m) == 0)
-            {                          // Is block free?
-                bp->data[bi / 8] |= m; // Mark block in use.
+            {
+                bp->data[bi / 8] |= m;
                 log_write(bp);
                 brelse(bp);
                 bzero(dev, b + bi);
@@ -85,7 +69,6 @@
     panic("balloc: out of blocks");
 }
 
-// Free a disk block.
 static void bfree(int dev, uint b)
 {
     struct buf *bp;
@@ -101,75 +84,6 @@
     brelse(bp);
 }
 
-// Inodes.
-//
-// An inode describes a single unnamed file.
-// The inode disk structure holds metadata: the file's type,
-// its size, the number of links referring to it, and the
-// list of blocks holding the file's content.
-//
-// The inodes are laid out sequentially on disk at
-// sb.startinode. Each inode has a number, indicating its
-// position on the disk.
-//
-// The kernel keeps a cache of in-use inodes in memory
-// to provide a place for synchronizing access
-// to inodes used by multiple processes. The cached
-// inodes include book-keeping information that is
-// not stored on disk: ip->ref and ip->valid.
-//
-// An inode and its in-memory representation go through a
-// sequence of states before they can be used by the
-// rest of the file system code.
-//
-// * Allocation: an inode is allocated if its type (on disk)
-//   is non-zero. ialloc() allocates, and iput() frees if
-//   the reference and link counts have fallen to zero.
-//
-// * Referencing in cache: an entry in the inode cache
-//   is free if ip->ref is zero. Otherwise ip->ref tracks
-//   the number of in-memory pointers to the entry (open
-//   files and current directories). iget() finds or
-//   creates a cache entry and increments its ref; iput()
-//   decrements ref.
-//
-// * Valid: the information (type, size, &c) in an inode
-//   cache entry is only correct when ip->valid is 1.
-//   ilock() reads the inode from
-//   the disk and sets ip->valid, while iput() clears
-//   ip->valid if ip->ref has fallen to zero.
-//
-// * Locked: file system code may only examine and modify
-//   the information in an inode and its content if it
-//   has first locked the inode.
-//
-// Thus a typical sequence is:
-//   ip = iget(dev, inum)
-//   ilock(ip)
-//   ... examine and modify ip->xxx ...
-//   iunlock(ip)
-//   iput(ip)
-//
-// ilock() is separate from iget() so that system calls can
-// get a long-term reference to an inode (as for an open file)
-// and only lock it for short periods (e.g., in read()).
-// The separation also helps avoid deadlock and races during
-// pathname lookup. iget() increments ip->ref so that the inode
-// stays cached and pointers to it remain valid.
-//
-// Many internal file system functions expect the caller to
-// have locked the inodes involved; this lets callers create
-// multi-step atomic operations.
-//
-// The icache.lock spin-lock protects the allocation of icache
-// entries. Since ip->ref indicates whether an entry is free,
-// and ip->dev and ip->inum indicate which i-node an entry
-// holds, one must hold icache.lock while using any of those fields.
-//
-// An ip->lock sleep-lock protects all ip-> fields other than ref,
-// dev, and inum.  One must hold ip->lock in order to
-// read or write that inode's ip->valid, ip->size, ip->type, &c.
-
 struct
 {
     struct spinlock lock;
@@ -189,25 +103,24 @@
 
 static struct inode *iget(uint dev, uint inum);
 
-/* TODO: Access Control & Symbolic Link */
-// Allocate an inode on device dev.
-// Mark it as allocated by  giving it type type.
-// Returns an unlocked but allocated and referenced inode.
 struct inode *ialloc(uint dev, short type)
 {
-    int inum;
     struct buf *bp;
     struct dinode *dip;
 
-    for (inum = 1; inum < sb.ninodes; inum++)
+    for (int inum = 1; inum < sb.ninodes; inum++)
     {
         bp = bread(dev, IBLOCK(inum, sb));
         dip = (struct dinode *)bp->data + inum % IPB;
+
         if (dip->type == 0)
-        { // a free inode
+        {
             memset(dip, 0, sizeof(*dip));
             dip->type = type;
-            log_write(bp); // mark it allocated on the disk
+            dip->major = 0;
+            dip->minor = M_ALL;
+            dip->nlink = 1;
+            log_write(bp);
             brelse(bp);
             return iget(dev, inum);
         }
@@ -216,11 +129,6 @@
     panic("ialloc: no inodes");
 }
 
-/* TODO: Access Control & Symbolic Link */
-// Copy a modified in-memory inode to disk.
-// Must be called after every change to an ip->xxx field
-// that lives on disk, since i-node cache is write-through.
-// Caller must hold ip->lock.
 void iupdate(struct inode *ip)
 {
     struct buf *bp;
@@ -228,26 +136,24 @@
 
     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
     dip = (struct dinode *)bp->data + ip->inum % IPB;
+
     dip->type = ip->type;
     dip->major = ip->major;
     dip->minor = ip->minor;
     dip->nlink = ip->nlink;
     dip->size = ip->size;
     memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+
     log_write(bp);
     brelse(bp);
 }
 
-// Find the inode with number inum on device dev
-// and return the in-memory copy. Does not lock
-// the inode and does not read it from disk.
 static struct inode *iget(uint dev, uint inum)
 {
     struct inode *ip, *empty;
 
     acquire(&icache.lock);
 
-    // Is the inode already cached?
     empty = 0;
     for (ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++)
     {
@@ -257,11 +163,10 @@
             release(&icache.lock);
             return ip;
         }
-        if (empty == 0 && ip->ref == 0) // Remember empty slot.
+        if (empty == 0 && ip->ref == 0)
             empty = ip;
     }
 
-    // Recycle an inode cache entry.
     if (empty == 0)
         panic("iget: no inodes");
 
@@ -275,8 +180,6 @@
     return ip;
 }
 
-// Increment reference count for ip.
-// Returns ip to enable ip = idup(ip1) idiom.
 struct inode *idup(struct inode *ip)
 {
     acquire(&icache.lock);
@@ -285,9 +188,6 @@
     return ip;
 }
 
-/* TODO: Access Control & Symbolic Link */
-// Lock the given inode.
-// Reads the inode from disk if necessary.
 void ilock(struct inode *ip)
 {
     struct buf *bp;
@@ -302,20 +202,22 @@
     {
         bp = bread(ip->dev, IBLOCK(ip->inum, sb));
         dip = (struct dinode *)bp->data + ip->inum % IPB;
+
         ip->type = dip->type;
         ip->major = dip->major;
         ip->minor = dip->minor;
         ip->nlink = dip->nlink;
         ip->size = dip->size;
         memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+
         brelse(bp);
         ip->valid = 1;
+
         if (ip->type == 0)
             panic("ilock: no type");
     }
 }
 
-// Unlock the given inode.
 void iunlock(struct inode *ip)
 {
     if (ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
@@ -324,23 +226,13 @@
     releasesleep(&ip->lock);
 }
 
-// Drop a reference to an in-memory inode.
-// If that was the last reference, the inode cache entry can
-// be recycled.
-// If that was the last reference and the inode has no links
-// to it, free the inode (and its content) on disk.
-// All calls to iput() must be inside a transaction in
-// case it has to free the inode.
 void iput(struct inode *ip)
 {
     acquire(&icache.lock);
 
     if (ip->ref == 1 && ip->valid && ip->nlink == 0)
     {
-        // inode has no links and no other references: truncate and free.
 
-        // ip->ref == 1 means no other process can have ip locked,
-        // so this acquiresleep() won't block (or deadlock).
         acquiresleep(&ip->lock);
 
         release(&icache.lock);
@@ -359,29 +251,18 @@
     release(&icache.lock);
 }
 
-// Common idiom: unlock, then put.
 void iunlockput(struct inode *ip)
 {
     iunlock(ip);
     iput(ip);
 }
 
-// Inode content
-//
-// The content (data) associated with each inode is stored
-// in blocks on the disk. The first NDIRECT block numbers
-// are listed in ip->addrs[].  The next NINDIRECT blocks are
-// listed in block ip->addrs[NDIRECT].
-
-// Return the disk block address of the nth block in inode ip.
-// If there is no such block, bmap allocates one.
-
 uint bmap(struct inode *ip, uint bn)
 {
     uint addr, *a;
     struct buf *bp;
 
-    if (bn < NDIRECT) //
+    if (bn < NDIRECT)
     {
         if ((addr = ip->addrs[bn]) == 0)
         {
@@ -406,19 +287,19 @@
         bp = bread(ip->dev, addr);
         a = (uint *)bp->data;
 
-        uint target_addr = a[bn];
+        uint t_addr = a[bn];
 
-        if (target_addr == 0)
+        if (t_addr == 0)
         {
-            target_addr = balloc(ip->dev);
-            if (target_addr == 0)
+            t_addr = balloc(ip->dev);
+            if (t_addr == 0)
                 panic("bmap: balloc failed for data block via indirect");
-            a[bn] = target_addr;
+            a[bn] = t_addr;
             log_write(bp);
         }
         brelse(bp);
 
-        return target_addr;
+        return t_addr;
     }
 
     printf("bmap: ERROR! file_bn %d is out of range for inode %d\n",
@@ -426,8 +307,6 @@
     panic("bmap: out of range");
 }
 
-// Truncate inode (discard contents).
-// Caller must hold ip->lock.
 void itrunc(struct inode *ip)
 {
     int i, j;
@@ -461,9 +340,6 @@
     iupdate(ip);
 }
 
-/* TODO: Access Control & Symbolic Link */
-// Copy stat information from inode.
-// Caller must hold ip->lock.
 void stati(struct inode *ip, struct stat *st)
 {
     st->dev = ip->dev;
@@ -471,17 +347,17 @@
     st->type = ip->type;
     st->nlink = ip->nlink;
     st->size = ip->size;
+    st->mode = ip->minor;
 }
 
-// Read data from inode.
-// Caller must hold ip->lock.
-// If user_dst==1, then dst is a user virtual address;
-// otherwise, dst is a kernel address.
 int readi(struct inode *ip, int user_dst, uint64 dst, uint off, uint n)
 {
     uint tot, m;
     struct buf *bp;
 
+    if (!(ip->type == T_FILE || ip->type == T_SYMLINK || ip->type == T_DIR))
+        return -1;
+
     if (off > ip->size || off + n < off)
         return 0;
     if (off + n > ip->size)
@@ -501,10 +377,6 @@
     return tot;
 }
 
-// Write data to inode.
-// Caller must hold ip->lock.
-// If user_src==1, then src is a user virtual address;
-// otherwise, src is a kernel address.
 int writei(struct inode *ip, int user_src, uint64 src, uint off, uint n)
 {
     uint tot, m;
@@ -534,21 +406,15 @@
     {
         if (off > ip->size)
             ip->size = off;
-        // write the i-node back to disk even if the size didn't change
-        // because the loop above might have called bmap() and added a new
-        // block to ip->addrs[].
+
         iupdate(ip);
     }
 
     return n;
 }
 
-// Directories
-
 int namecmp(const char *s, const char *t) { return strncmp(s, t, DIRSIZ); }
 
-// Look for a directory entry in a directory.
-// If found, set *poff to byte offset of entry.
 struct inode *dirlookup(struct inode *dp, char *name, uint *poff)
 {
     uint off, inum;
@@ -565,7 +431,7 @@
             continue;
         if (namecmp(name, de.name) == 0)
         {
-            // entry matches path element
+
             if (poff)
                 *poff = off;
             inum = de.inum;
@@ -576,21 +442,18 @@
     return 0;
 }
 
-// Write a new directory entry (name, inum) into the directory dp.
 int dirlink(struct inode *dp, char *name, uint inum)
 {
     int off;
     struct dirent de;
     struct inode *ip;
 
-    // Check that name is not present.
     if ((ip = dirlookup(dp, name, 0)) != 0)
     {
         iput(ip);
         return -1;
     }
 
-    // Look for an empty dirent.
     for (off = 0; off < dp->size; off += sizeof(de))
     {
         if (readi(dp, 0, (uint64)&de, off, sizeof(de)) != sizeof(de))
@@ -607,20 +470,6 @@
     return 0;
 }
 
-// Paths
-
-// Copy the next path element from path into name.
-// Return a pointer to the element following the copied one.
-// The returned path has no leading slashes,
-// so the caller can check *path=='\0' to see if the name is the last one.
-// If no name to remove, return 0.
-//
-// Examples:
-//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
-//   skipelem("///a//bb", name) = "bb", setting name = "a"
-//   skipelem("a", name) = "", setting name = "a"
-//   skipelem("", name) = skipelem("////", name) = 0
-//
 static char *skipelem(char *path, char *name)
 {
     char *s;
@@ -646,11 +495,7 @@
     return path;
 }
 
-// Look up and return the inode for a path name.
-// If parent != 0, return the inode for the parent and copy the final
-// path element into name, which must have room for DIRSIZ bytes.
-// Must be called inside a transaction since it calls iput().
-static struct inode *namex(char *path, int nameiparent, char *name)
+struct inode *namex(char *path, int nameiparent, char *name)
 {
     struct inode *ip, *next;
 
@@ -662,6 +507,13 @@
     while ((path = skipelem(path, name)) != 0)
     {
         ilock(ip);
+        if (ip->type == T_DIR && !(ip->minor & M_READ))
+        {
+
+            iunlockput(ip);
+
+            return 0;
+        }
         if (ip->type != T_DIR)
         {
             iunlockput(ip);
@@ -669,7 +521,7 @@
         }
         if (nameiparent && *path == '\0')
         {
-            // Stop one level early.
+
             iunlock(ip);
             return ip;
         }
@@ -680,6 +532,45 @@
         }
         iunlockput(ip);
         ip = next;
+        ilock(ip);
+
+        if (ip->type == T_SYMLINK)
+        {
+
+            char t[MAXPATH], newpath[MAXPATH];
+
+            int n = readi(ip, 0, (uint64)t, 0, MAXPATH - 1);
+
+            iunlockput(ip);
+
+            if (n < 0)
+
+                return 0;
+
+            t[n] = '\0';
+
+            int tlen = strlen(t);
+
+            int plen = strlen(path);
+
+            if (tlen + 1 + plen >= MAXPATH)
+
+                return 0;
+
+            memmove(newpath, t, tlen);
+
+            newpath[tlen] = '/';
+
+            memmove(newpath + tlen + 1, path, plen);
+
+            newpath[tlen + 1 + plen] = '\0';
+
+            iput(ip);
+
+            return namex(newpath, nameiparent, name);
+        }
+
+        iunlock(ip);
     }
     if (nameiparent)
     {
@@ -692,6 +583,29 @@
 struct inode *namei(char *path)
 {
     char name[DIRSIZ];
+    struct inode *ip = namex(path, 0, name);
+
+    while (ip && ip->type == T_SYMLINK)
+    {
+
+        char buf[MAXPATH];
+
+        int n = readi(ip, 0, (uint64)buf, 0, MAXPATH - 1);
+
+        if (n < 0)
+        {
+
+            iput(ip);
+
+            return 0;
+        }
+
+        buf[n] = '\0';
+
+        iput(ip);
+
+        ip = namei(buf);
+    }
     return namex(path, 0, name);
 }
 
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/kernel/stat.h mp4-new/kernel/stat.h
--- mp4/kernel/stat.h	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/kernel/stat.h	2025-05-22 19:20:12.702090600 +0800
@@ -15,4 +15,5 @@
     short type;  // Type of file
     short nlink; // Number of links to file
     uint64 size; // Size of file in bytes
+    short mode;
 };
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/kernel/syscall.c mp4-new/kernel/syscall.c
--- mp4/kernel/syscall.c	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/kernel/syscall.c	2025-05-22 19:20:12.741587100 +0800
@@ -107,6 +107,7 @@
 extern uint64 sys_force_disk_fail(void);
 /* TODO: Access Control & Symbolic Link */
 extern uint64 sys_symlink(void);
+extern uint64 sys_chmod(void);
 
 static uint64 (*syscalls[])(void) = {
     [SYS_fork] sys_fork,
@@ -137,6 +138,7 @@
     [SYS_get_disk_lbn] sys_get_disk_lbn,
     [SYS_raw_write] sys_raw_write,
     [SYS_force_disk_fail] sys_force_disk_fail,
+    [SYS_chmod] sys_chmod,
 };
 
 void syscall(void)
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/kernel/syscall.h mp4-new/kernel/syscall.h
--- mp4/kernel/syscall.h	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/kernel/syscall.h	2025-05-22 19:20:12.374051900 +0800
@@ -28,5 +28,5 @@
 #define SYS_force_disk_fail 27
 
 /* TODO: Access Control & Symbolic Link */
-// #define SYS_chmod 28
+#define SYS_chmod 28
 #define SYS_symlink 29
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/kernel/sysfile.c mp4-new/kernel/sysfile.c
--- mp4/kernel/sysfile.c	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/kernel/sysfile.c	2025-05-22 19:20:12.694060500 +0800
@@ -1,8 +1,4 @@
-//
-// File-system system calls.
-// Mostly argument checking, since we don't trust
-// user code, and calls into file.c and fs.c.
-//
+
 
 #include "types.h"
 #include "riscv.h"
@@ -17,8 +13,65 @@
 #include "fcntl.h"
 #include "buf.h"
 
-// Fetch the nth word-sized system call argument as a file descriptor
-// and return both the descriptor and the corresponding struct file.
+#define PATH_MAX 128
+
+#define DIRSIZ 14
+struct inode *namex(char *path, int nameiparent, char *name);
+
+char *skipelem(char *path, char *name)
+{
+    while (*path == '/')
+        path++;
+    if (*path == 0)
+    {
+        name[0] = 0;
+        return 0;
+    }
+    char *s = path;
+    while (*path != '/' && *path != 0)
+        path++;
+    int len = path - s;
+    if (len >= DIRSIZ)
+        memmove(name, s, DIRSIZ);
+    else
+    {
+        memmove(name, s, len);
+        name[len] = 0;
+    }
+    while (*path == '/')
+        path++;
+    return path;
+}
+int safestrcat(char *dst, const char *src, int max)
+{
+    int i = 0;
+    while (dst[i] && i < max)
+        i++;
+    int j = 0;
+    while (src[j] && i + j + 1 < max)
+    {
+        dst[i + j] = src[j];
+        j++;
+    }
+    if (i + j < max)
+        dst[i + j] = '\0';
+    else if (max > 0)
+        dst[max - 1] = '\0';
+    return i + j;
+}
+
+char *kstrchr(const char *s, char c)
+{
+    while (*s)
+    {
+        if (*s == c)
+            return (char *)s;
+        s++;
+    }
+    return 0;
+}
+static int chmod_walk(char *path, int add, int bits, int recursive);
+
 static int argfd(int n, int *pfd, struct file **pf)
 {
     int fd;
@@ -35,8 +88,6 @@
     return 0;
 }
 
-// Allocate a file descriptor for the given file.
-// Takes over file reference from caller on success.
 static int fdalloc(struct file *f)
 {
     int fd;
@@ -104,14 +155,13 @@
 uint64 sys_fstat(void)
 {
     struct file *f;
-    uint64 st; // user pointer to struct stat
+    uint64 st;
 
     if (argfd(0, 0, &f) < 0 || argaddr(1, &st) < 0)
         return -1;
     return filestat(f, st);
 }
 
-// Create the path new as a link to the same inode as old.
 uint64 sys_link(void)
 {
     char name[DIRSIZ], new[MAXPATH], old[MAXPATH];
@@ -163,7 +213,6 @@
     return -1;
 }
 
-// Is the directory dp empty except for "." and ".." ?
 static int isdirempty(struct inode *dp)
 {
     int off;
@@ -198,7 +247,6 @@
 
     ilock(dp);
 
-    // Cannot unlink "." or "..".
     if (namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
         goto bad;
 
@@ -262,16 +310,18 @@
         panic("create: ialloc");
 
     ilock(ip);
+    ip->nlink = 1;
+
     ip->major = major;
+
     ip->minor = minor;
-    ip->nlink = 1;
     iupdate(ip);
 
     if (type == T_DIR)
-    {                // Create . and .. entries.
-        dp->nlink++; // for ".."
+    {
+        dp->nlink++;
         iupdate(dp);
-        // No ip->nlink++ for ".": avoid cyclic ref count.
+
         if (dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
             panic("create dots");
     }
@@ -283,85 +333,235 @@
 
     return ip;
 }
+#define SYMLOOP_MAX 10
+#define PATH_SEP '/'
+
+static int readlink_target(struct inode *ip, char *buf, int bufsize)
+{
+    if (ip->size >= bufsize)
+        return -1;
+    int n = readi(ip, 0, (uint64)buf, 0, ip->size);
+    buf[n] = '\0';
+    return 0;
+}
 
-/* TODO: Access Control & Symbolic Link */
+static int path_join(char *new, const char *base, const char *rest, int max)
+{
+    if (strlen(base) + 1 + strlen(rest) + 1 > max)
+        return -1;
+    safestrcpy(new, base, max);
+    if (new[0] == '\0')
+        safestrcpy(new, rest, max);
+    else
+    {
+
+        if (new[strlen(new) - 1] != PATH_SEP)
+            safestrcat(new, "/", max);
+        safestrcat(new, rest, max);
+    }
+    return 0;
+}
+
+char *kstrrchr(const char *s, char c)
+{
+    char *last = 0;
+    while (*s)
+    {
+        if (*s == c)
+            last = (char *)s;
+        s++;
+    }
+    return last;
+}
 uint64 sys_open(void)
 {
     char path[MAXPATH];
-    int fd, omode;
-    struct file *f;
-    struct inode *ip;
-    int n;
+    int omode;
 
-    if ((n = argstr(0, path, MAXPATH)) < 0 || argint(1, &omode) < 0)
+    // 取得使用者參數 ----------------------------------------------------------
+    if (argstr(0, path, MAXPATH) < 0 || argint(1, &omode) < 0)
         return -1;
 
-    begin_op();
-
-    if (omode & O_CREATE)
+    // 迴圈展開 symlink；最多追 10 次避免循環
+    for (int depth = 0; depth < 10; depth++)
     {
-        ip = create(path, T_FILE, 0, 0);
-        if (ip == 0)
+        struct inode *ip;
+        struct file *f;
+        int fd;
+
+        begin_op();
+
+        // ─────────────────────────── 1) 處理 O_CREATE
+        // ──────────────────────────
+        if (omode & O_CREATE)
         {
-            end_op();
-            return -1;
+            ip = create(path, T_FILE, 0, M_ALL); // 新檔案 rw 預設權限
+            if (ip == 0)
+            {
+                end_op();
+                return -1;
+            }
         }
-    }
-    else
-    {
-        if ((ip = namei(path)) == 0)
+
+        // ──────────────────────── 2) 非 create 的開檔
+        // ──────────────────────────
+        else
         {
+            // ---------- (2a) O_NOACCESS：只拿 inode, 不跟隨 leaf ----------
+            if (omode & O_NOACCESS)
+            {
+                char parent[MAXPATH], leaf[DIRSIZ];
+
+                // 切割父目錄與 leaf
+                char *slash = kstrrchr(path, '/');
+                if (slash)
+                {
+                    int plen = slash - path;
+                    if (plen >= MAXPATH)
+                        plen = MAXPATH - 1;
+                    memmove(parent, path, plen);
+                    parent[plen] = '\0';
+                    safestrcpy(leaf, slash + 1, sizeof(leaf));
+                }
+                else
+                {
+                    safestrcpy(parent, ".", sizeof(parent));
+                    safestrcpy(leaf, path, sizeof(leaf));
+                }
+
+                // 取得 parent inode（不跟隨 leaf）
+                ip = namex(path, 1, leaf);
+                if (!ip)
+                {
+                    end_op();
+                    return -1;
+                }
+                ilock(ip);
+
+                // 若 parent 本身是 symlink，追一次
+                while (ip->type == T_SYMLINK)
+                {
+                    char buf[MAXPATH];
+                    int n = readi(ip, 0, (uint64)buf, 0, MAXPATH - 1);
+                    iunlockput(ip);
+                    end_op();
+                    if (n < 0)
+                        return -1;
+                    buf[n] = 0;
+                    safestrcpy(path, buf, MAXPATH); // 轉向；重新 loop
+                    goto loop_continue;
+                }
+
+                if (ip->type != T_DIR)
+                {
+                    iunlockput(ip);
+                    end_op();
+                    return -1;
+                }
+
+                // 在 parent 內查 leaf (不跟隨 leaf symlink)
+                struct inode *dp = ip;
+                ip = dirlookup(dp, leaf, 0);
+                iunlockput(dp);
+                if (!ip)
+                {
+                    end_op();
+                    return -1;
+                }
+                ilock(ip);
+            }
+            // ---------- (2b) Normal open：會跟隨 leaf symlink ----------
+            else
+            {
+                ip = namei(path); // 預設會解析 symlink
+                if (!ip)
+                {
+                    end_op();
+                    return -1;
+                }
+                ilock(ip);
+            }
+
+            // ---------- (2c) 若開到 symlink，讀其 target 再重來 ----------
+            if (!(omode & O_NOACCESS) && ip->type == T_SYMLINK)
+            {
+                char target[MAXPATH];
+                int n = readi(ip, 0, (uint64)target, 0, MAXPATH - 1);
+                iunlockput(ip);
+                end_op();
+                if (n < 0)
+                    return -1;
+                target[n] = 0;
+                safestrcpy(path, target, MAXPATH);
+                continue; // loop 追下一層
+            }
+
+            // ---------- (2d) 權限檢查 (若非 O_NOACCESS) ----------
+            if (!(omode & O_NOACCESS))
+            {
+                int wantR = !(omode & O_WRONLY);
+                int wantW = (omode & O_WRONLY) || (omode & O_RDWR);
+                int ok = !(wantR && !(ip->minor & M_READ)) &&
+                         !(wantW && !(ip->minor & M_WRITE)) &&
+                         !(ip->type == T_DIR && wantW);
+                if (!ok)
+                {
+                    iunlockput(ip);
+                    end_op();
+                    return -1;
+                }
+            }
+        }
+
+        // ───────────────────── 3) 特殊裝置號檢查
+        // ───────────────────────────────
+        if (ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV))
+        {
+            iunlockput(ip);
             end_op();
             return -1;
         }
-        ilock(ip);
-        if (ip->type == T_DIR && omode != O_RDONLY)
+
+        // ───────────────────── 4) 配置 file 與 fd
+        // ──────────────────────────────
+        if ((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0)
         {
+            if (f)
+                fileclose(f);
             iunlockput(ip);
             end_op();
             return -1;
         }
-    }
 
-    if (ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV))
-    {
-        iunlockput(ip);
-        end_op();
-        return -1;
-    }
-
-    if ((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0)
-    {
-        if (f)
-            fileclose(f);
-        iunlockput(ip);
-        end_op();
-        return -1;
-    }
-
-    if (ip->type == T_DEVICE)
-    {
-        f->type = FD_DEVICE;
+        // ───────────────────── 5) 初始化 file 結構
+        // ─────────────────────────────
+        f->type = (ip->type == T_DEVICE ? FD_DEVICE : FD_INODE);
         f->major = ip->major;
-    }
-    else
-    {
-        f->type = FD_INODE;
+        f->ip = ip;
         f->off = 0;
-    }
-    f->ip = ip;
-    f->readable = !(omode & O_WRONLY);
-    f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
 
-    if ((omode & O_TRUNC) && ip->type == T_FILE)
-    {
-        itrunc(ip);
-    }
+        if ((omode & O_NOACCESS) && ip->type != T_SYMLINK)
+        {
+            f->readable = f->writable = 0;
+        }
+        else
+        {
+            f->readable = !(omode & O_WRONLY);
+            f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+        }
 
-    iunlock(ip);
-    end_op();
+        if ((omode & O_TRUNC) && ip->type == T_FILE)
+            itrunc(ip);
 
-    return fd;
+        iunlock(ip);
+        end_op();
+        return fd;
+
+    loop_continue:; // label target；什麼都不做，for 迴圈會繼續
+    }
+
+    // 超過 symlink 深度限制
+    return -1;
 }
 
 uint64 sys_mkdir(void)
@@ -370,7 +570,8 @@
     struct inode *ip;
 
     begin_op();
-    if (argstr(0, path, MAXPATH) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0)
+    if (argstr(0, path, MAXPATH) < 0 ||
+        (ip = create(path, T_DIR, 0, M_ALL)) == 0)
     {
         end_op();
         return -1;
@@ -389,7 +590,7 @@
     begin_op();
     if ((argstr(0, path, MAXPATH)) < 0 || argint(1, &major) < 0 ||
         argint(2, &minor) < 0 ||
-        (ip = create(path, T_DEVICE, major, minor)) == 0)
+        (ip = create(path, T_DEVICE, major, M_ALL)) == 0)
     {
         end_op();
         return -1;
@@ -473,7 +674,7 @@
 
 uint64 sys_pipe(void)
 {
-    uint64 fdarray; // user pointer to array of two integers
+    uint64 fdarray;
     struct file *rf, *wf;
     int fd0, fd1;
     struct proc *p = myproc();
@@ -504,36 +705,47 @@
     return 0;
 }
 
-/* TODO: Access Control & Symbolic Link */
-uint64 sys_chmod(void)
+uint64 sys_symlink(void)
+
 {
-    /* just for your reference, change it if you want to */
 
-    // char path[MAXPATH];
-    // int mode;
-    // struct inode *ip;
+    char target[MAXPATH], path[MAXPATH];
 
-    // begin_op();
-    // if (argstr(0, path, MAXPATH) < 0 || argint(1, &mode) < 0 ||
-    //     (ip = namei(path)) == 0)
-    // {
-    //     end_op();
-    //     return -1;
-    // }
-    // end_op();
+    struct inode *ip;
 
-    return 0;
-}
+    if (argstr(0, target, MAXPATH) < 0 || argstr(1, path, MAXPATH) < 0)
 
-/* TODO: Access Control & Symbolic Link */
-uint64 sys_symlink(void)
-{
-    /* just for your reference, change it if you want to */
+    {
 
-    // char target[MAXPATH], path[MAXPATH];
+        return -1;
+    }
+
+    begin_op();
+
+    ip = create(path, T_SYMLINK, 0, M_ALL);
+
+    if (ip == 0)
+    {
+
+        end_op();
+
+        return -1;
+    }
 
-    // if (argstr(0, target, MAXPATH) < 0 || argstr(1, path, MAXPATH) < 0)
-    //     return -1;
+    if (writei(ip, 0, (uint64)target, 0, strlen(target)) != strlen(target))
+
+    {
+
+        iunlockput(ip);
+
+        end_op();
+
+        return -1;
+    }
+
+    iunlockput(ip);
+
+    end_op();
 
     return 0;
 }
@@ -636,3 +848,110 @@
 
     return 0;
 }
+
+static int chmod_walk(char *path, int add, int bits, int recursive)
+{
+    struct inode *ip;
+    if ((ip = namei(path)) == 0)
+        return -1;
+    ilock(ip);
+
+    int isdir = (ip->type == T_DIR);
+    int preorder = 1;
+
+    if (recursive && isdir)
+    {
+        if (!add && (bits & M_READ))
+            preorder = 0;
+        if (add && (bits & M_READ) && !(ip->minor & M_READ))
+            preorder = 1;
+    }
+
+    if (preorder)
+    {
+        ip->minor = add ? (ip->minor | bits) : (ip->minor & ~bits);
+        iupdate(ip);
+    }
+
+    if (recursive && isdir && (ip->minor & M_READ))
+    {
+        struct dirent de;
+        char child[MAXPATH];
+        for (uint off = 0; off < ip->size; off += sizeof(de))
+        {
+            if (readi(ip, 0, (uint64)&de, off, sizeof(de)) != sizeof(de))
+                break;
+            if (de.inum == 0)
+                continue;
+            if (namecmp(de.name, ".") == 0 || namecmp(de.name, "..") == 0)
+                continue;
+
+            int len = strlen(path);
+            if (len + 1 + DIRSIZ + 1 >= MAXPATH)
+            {
+                iunlock(ip);
+                return -1;
+            }
+            memmove(child, path, len);
+            child[len] = '/';
+            memmove(child + len + 1, de.name, DIRSIZ);
+            child[len + 1 + DIRSIZ] = 0;
+
+            iunlock(ip);
+            int r = chmod_walk(child, add, bits, 1);
+            ilock(ip);
+            if (r < 0)
+            {
+                iunlock(ip);
+                return -1;
+            }
+        }
+    }
+
+    if (!preorder)
+    {
+        ip->minor = add ? (ip->minor | bits) : (ip->minor & ~bits);
+        iupdate(ip);
+    }
+    iunlock(ip);
+    return 0;
+}
+
+uint64 sys_chmod(void)
+{
+
+    char path[128];
+
+    int mode_op;
+
+    if (argint(0, &mode_op) < 0 || argstr(1, path, sizeof(path)) < 0)
+
+        return -1;
+
+    begin_op();
+
+    struct inode *ip = namei(path);
+
+    if (ip == 0)
+
+    {
+
+        end_op();
+
+        return -1;
+    }
+
+    ilock(ip);
+
+    ip->minor = mode_op;
+
+    iupdate(ip);
+
+    iunlock(ip);
+
+    iput(ip);
+
+    end_op();
+
+    return 0;
+}
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/mkfs/mkfs.c mp4-new/mkfs/mkfs.c
--- mp4/mkfs/mkfs.c	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/mkfs/mkfs.c	2025-05-22 19:20:11.920263800 +0800
@@ -5,7 +5,7 @@
 #include <fcntl.h>
 #include <assert.h>
 
-#define stat xv6_stat // avoid clash with host struct stat
+#define stat xv6_stat
 #include "kernel/types.h"
 #include "kernel/fs.h"
 #include "kernel/stat.h"
@@ -23,14 +23,11 @@
 
 #define NINODES 200
 
-// Disk layout:
-// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
-
 int nbitmap = LOGICAL_DISK_SIZE / (BSIZE * 8) + 1;
 int ninodeblocks = NINODES / IPB + 1;
 int nlog = LOGSIZE;
-int nmeta;   // Number of meta blocks (boot, sb, nlog, inode, bitmap)
-int nblocks; // Number of data blocks
+int nmeta;
+int nblocks;
 
 int fsfd;
 struct superblock sb;
@@ -46,7 +43,6 @@
 uint ialloc(ushort type);
 void iappend(uint inum, void *p, int n);
 
-// convert to intel byte order
 ushort xshort(ushort x)
 {
     ushort y;
@@ -67,7 +63,6 @@
     return y;
 }
 
-/* TODO: Access Control & Symbolic Link */
 int main(int argc, char *argv[])
 {
     int i, cc, fd;
@@ -94,7 +89,6 @@
         exit(1);
     }
 
-    // 1 fs block = 1 disk sector
     nmeta = 2 + nlog + ninodeblocks + nbitmap;
     nblocks = LOGICAL_DISK_SIZE - nmeta;
 
@@ -111,7 +105,7 @@
            "blocks %u) blocks %d total %d\n",
            nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
 
-    freeblock = nmeta; // the first free block that we can allocate
+    freeblock = nmeta;
 
     for (i = 0; i < FSSIZE; i++)
         wsect(i, zeroes);
@@ -137,7 +131,6 @@
     {
         char *shortname;
 
-        // get rid of "user/"
         if (strncmp(argv[i], "user/", 5) == 0)
             shortname = argv[i] + 5;
         else
@@ -151,10 +144,6 @@
             exit(1);
         }
 
-        // Skip leading _ in name when writing to file system.
-        // The binaries are named _rm, _cat, etc. to keep the
-        // build operating system from trying to execute them
-        // in place of system binaries like rm and cat.
         if (shortname[0] == '_')
             shortname += 1;
 
@@ -171,7 +160,6 @@
         close(fd);
     }
 
-    // fix size of root inode dir
     rinode(rootino, &din);
     off = xint(din.size);
     off = ((off / BSIZE) + 1) * BSIZE;
@@ -236,7 +224,6 @@
     }
 }
 
-/* TODO: Access Control & Symbolic Link */
 uint ialloc(ushort type)
 {
     uint inum = freeinode++;
@@ -244,6 +231,8 @@
 
     bzero(&din, sizeof(din));
     din.type = xshort(type);
+    din.major = xshort(0);
+    din.minor = xshort(M_ALL);
     din.nlink = xshort(1);
     din.size = xint(0);
     winode(inum, &din);
@@ -279,7 +268,7 @@
 
     rinode(inum, &din);
     off = xint(din.size);
-    // printf("append inum %d at off %d sz %d\n", inum, off, n);
+
     while (n > 0)
     {
         fbn = off / BSIZE;
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/user/chmod.c mp4-new/user/chmod.c
--- mp4/user/chmod.c	1970-01-01 08:00:00.000000000 +0800
+++ mp4-new/user/chmod.c	2025-05-22 19:20:12.269283800 +0800
@@ -0,0 +1,304 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "kernel/fs.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+
+#define MAXPATH 128
+
+#ifndef M_READ
+#define M_READ 1
+#define M_WRITE 2
+#endif
+
+/* 只有一個輔助函式：安全字串複製 */
+static void safestrcpy(char *dst, const char *src, int n)
+{
+    if (n <= 0)
+        return;
+    while (--n > 0 && *src)
+        *dst++ = *src++;
+    *dst = '\0';
+}
+
+/* 解析 symlink → out 為最終實體路徑；若失敗傳 -1 */
+static int resolve(const char *in, char out[MAXPATH])
+{
+    char buf[MAXPATH], tmp[MAXPATH];
+    safestrcpy(buf, in, MAXPATH);
+    while (1)
+    {
+        int fd = open(buf, O_NOACCESS);
+        if (fd < 0)
+            return -1;
+        struct stat st;
+        if (fstat(fd, &st) < 0)
+        {
+            close(fd);
+            return -1;
+        }
+        if (st.type != T_SYMLINK)
+        {
+            close(fd);
+            break;
+        }
+        int n = read(fd, tmp, sizeof(tmp) - 1);
+        close(fd);
+        if (n <= 0)
+            return -1;
+        tmp[n] = '\0';
+        safestrcpy(buf, tmp, MAXPATH);
+    }
+    safestrcpy(out, buf, MAXPATH);
+    return 0;
+}
+
+int main(int argc, char *argv[])
+{
+    /* ───── 參數解析 ───── */
+    int recursive = 0, op = 0, bits = 0;
+    char *mode_str, *target;
+    if (argc == 4 && !strcmp(argv[1], "-R"))
+    {
+        recursive = 1;
+        mode_str = argv[2];
+        target = argv[3];
+    }
+    else if (argc == 3)
+    {
+        mode_str = argv[1];
+        target = argv[2];
+    }
+    else
+    {
+        fprintf(2, "Usage: chmod [-R] (+|-)(r|w|rw|wr) file_name|dir_name\n");
+        exit(1);
+    }
+
+    /* (+|-)rw 解析 */
+    if (!(mode_str[0] == '+' || mode_str[0] == '-'))
+    {
+        fprintf(2, "Usage: chmod [-R] (+|-)(r|w|rw|wr) file_name|dir_name\n");
+        exit(1);
+    }
+    op = (mode_str[0] == '+') ? +1 : -1;
+    for (int i = 1; mode_str[i]; i++)
+    {
+        if (mode_str[i] == 'r')
+            bits |= M_READ;
+        else if (mode_str[i] == 'w')
+            bits |= M_WRITE;
+        else
+        {
+            fprintf(2,
+                    "Usage: chmod [-R] (+|-)(r|w|rw|wr) file_name|dir_name\n");
+            exit(1);
+        }
+    }
+    if (bits == 0)
+    {
+        fprintf(2, "Usage: chmod [-R] (+|-)(r|w|rw|wr) file_name|dir_name\n");
+        exit(1);
+    }
+
+    /* 保存使用者原始輸入 (錯誤訊息要用) */
+    char g_origin[MAXPATH];
+    safestrcpy(g_origin, target, MAXPATH);
+
+    /* ───── symlink 解析 ───── */
+    char root[MAXPATH];
+    if (resolve(target, root) < 0)
+    {
+        fprintf(2, "chmod: cannot chmod %s\n", target);
+        exit(1);
+    }
+
+    /* ───── 非遞迴模式：直接 chmod 後結束 ───── */
+    if (!recursive)
+    {
+        int fd = open(root, O_NOACCESS);
+        if (fd < 0)
+        {
+            fprintf(2, "chmod: cannot open %s\n", root);
+            exit(1);
+        }
+        struct stat st;
+        if (fstat(fd, &st) < 0)
+        {
+            close(fd);
+            fprintf(2, "chmod: cannot stat %s\n", root);
+            exit(1);
+        }
+        close(fd);
+        int newmode = (op > 0) ? (st.mode | bits) : (st.mode & ~bits);
+        if (chmod(newmode, root) < 0)
+            fprintf(2, "chmod: cannot chmod %s\n", root);
+        exit(0);
+    }
+
+    /* ───── 遞迴前檢查 root 可讀性 (規格要求) ───── */
+    {
+        int fd = open(root, O_NOACCESS);
+        if (fd < 0)
+        {
+            fprintf(2, "chmod: cannot chmod %s\n", target);
+            exit(1);
+        }
+        struct stat st;
+        if (fstat(fd, &st) < 0)
+        {
+            close(fd);
+            fprintf(2, "chmod: cannot chmod %s\n", target);
+            exit(1);
+        }
+        close(fd);
+        if (!(st.mode & M_READ) && op < 0)
+        {
+            fprintf(2, "chmod: cannot chmod %s\n", target);
+            exit(1);
+        }
+    }
+
+    /* ───── 迭代 DFS (僅此一函式實作) ───── */
+    /* 迭代用顯式 stack：宣告在全域，避免壓爆使用者執行緒的 8 KB stack */
+    struct Frame
+    {
+        char path[MAXPATH];
+        int need_tmp_r;
+        int post;
+    };
+    static struct Frame stack[1024];
+    int top = 0;
+    safestrcpy(stack[0].path, root, MAXPATH);
+    stack[0].need_tmp_r = 0;
+    stack[0].post = 0;
+
+    while (top >= 0)
+    {
+        struct Frame cur = stack[top--];
+
+        /* ───── Post‑order：真正執行 chmod + 還原 tmp r ───── */
+        if (cur.post)
+        {
+            int fd = open(cur.path, O_NOACCESS);
+            if (fd < 0)
+            {
+                fprintf(2, "chmod: cannot open %s\n", cur.path);
+            }
+            else
+            {
+                struct stat st;
+                if (fstat(fd, &st) < 0)
+                {
+                    close(fd);
+                    fprintf(2, "chmod: cannot stat %s\n", cur.path);
+                }
+                else
+                {
+                    int newmode =
+                        (op > 0) ? (st.mode | bits) : (st.mode & ~bits);
+                    if (chmod(newmode, cur.path) < 0)
+                        fprintf(2, "chmod: cannot chmod %s\n", cur.path);
+                    close(fd);
+                }
+            }
+            if (cur.need_tmp_r && op < 0 && (bits & M_READ))
+            {
+                int fd = open(cur.path, O_NOACCESS);
+                if (fd >= 0)
+                {
+                    struct stat st;
+                    if (fstat(fd, &st) == 0)
+                    {
+                        int nm = st.mode & ~M_READ;
+                        if (chmod(nm, cur.path) < 0)
+                            fprintf(2, "chmod: cannot restore r from %s\n",
+                                    cur.path);
+                    }
+                    close(fd);
+                }
+            }
+            continue;
+        }
+
+        /* ───── Pre‑order：檢查型別、暫時 +r、push 子項 ───── */
+        int fd = open(cur.path, O_NOACCESS);
+        if (fd < 0)
+        {
+            fprintf(2, "chmod: cannot chmod %s\n", g_origin);
+            continue;
+        }
+        struct stat st;
+        if (fstat(fd, &st) < 0)
+        {
+            close(fd);
+            fprintf(2, "chmod: cannot chmod %s\n", g_origin);
+            continue;
+        }
+        close(fd);
+
+        int is_dir = (st.type == T_DIR);
+        if (is_dir && op < 0 && !(st.mode & M_READ))
+        {
+            fprintf(2, "chmod: cannot chmod %s\n", g_origin);
+            continue;
+        }
+
+        int need_tmp_r = 0;
+        if (is_dir && op > 0 && (bits & M_READ) && !(st.mode & M_READ))
+        {
+            int nm = st.mode | M_READ;
+            if (chmod(nm, cur.path) < 0)
+            {
+                fprintf(2, "chmod: cannot chmod %s\n", g_origin);
+                continue;
+            }
+            need_tmp_r = 1;
+        }
+
+        /* push postorder frame */
+        ++top;
+        safestrcpy(stack[top].path, cur.path, MAXPATH);
+        stack[top].need_tmp_r = need_tmp_r;
+        stack[top].post = 1;
+
+        /* 探索子目錄 */
+        if (is_dir)
+        {
+            int dfd = open(cur.path, O_RDONLY);
+            if (dfd < 0)
+            {
+                fprintf(2, "chmod: cannot open directory %s\n", cur.path);
+                continue;
+            }
+            struct dirent de;
+            char buf[512];
+            while (read(dfd, &de, sizeof(de)) == sizeof(de))
+            {
+                if (de.inum == 0 || !strcmp(de.name, ".") ||
+                    !strcmp(de.name, ".."))
+                    continue;
+                safestrcpy(buf, cur.path, sizeof(buf));
+                int len = strlen(buf);
+                buf[len++] = '/';
+                int nlen = strlen(de.name);
+                if (nlen > DIRSIZ)
+                    nlen = DIRSIZ;
+                memmove(buf + len, de.name, nlen);
+                buf[len + nlen] = '\0';
+                char real[MAXPATH];
+                if (resolve(buf, real) < 0)
+                {
+                    fprintf(2, "chmod: cannot resolve %s\n", buf);
+                    continue;
+                }
+                ++top;
+                safestrcpy(stack[top].path, real, MAXPATH);
+                stack[top].need_tmp_r = 0;
+                stack[top].post = 0;
+            }
+            close(dfd);
+        }
+    }
+    exit(0);
+}
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/user/ls.c mp4-new/user/ls.c
--- mp4/user/ls.c	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/user/ls.c	2025-05-22 19:20:12.148550600 +0800
@@ -1,19 +1,33 @@
+// user/ls.c  ── “[1] style”
+// ======================================================================
 #include "kernel/types.h"
 #include "kernel/stat.h"
-#include "user/user.h"
 #include "kernel/fs.h"
+#include "kernel/fcntl.h"
+#include "user/user.h"
+
+#define MAXPATH 128
+
+// ───── util ────────────────────────────────────────────────────────────
+static void safestrcpy(char *dst, const char *src, int n)
+{
+    if (n <= 0)
+        return;
+    while (--n > 0 && *src)
+        *dst++ = *src++;
+    *dst = '\0';
+}
 
-char *fmtname(char *path)
+// blank-padded name (同 [1] 的 fmtname)
+static char *fmtname(char *path)
 {
     static char buf[DIRSIZ + 1];
     char *p;
 
-    // Find first character after last slash.
     for (p = path + strlen(path); p >= path && *p != '/'; p--)
         ;
-    p++;
+    p++; // now p 指到最後一節
 
-    // Return blank-padded name.
     if (strlen(p) >= DIRSIZ)
         return p;
     memmove(buf, p, strlen(p));
@@ -21,35 +35,47 @@
     return buf;
 }
 
-/* TODO: Access Control & Symbolic Link */
-void ls(char *path)
+// ───── core ls ─────────────────────────────────────────────────────────
+static void ls(char *path)
 {
     char buf[512], *p;
     int fd;
     struct dirent de;
     struct stat st;
 
-    if ((fd = open(path, 0)) < 0)
+    // ① 先用 stat() 取 metadata，且要求目標本身有 r 權限
+    if (stat(path, &st) < 0 || !(st.mode & M_READ))
     {
         fprintf(2, "ls: cannot open %s\n", path);
         return;
     }
 
-    if (fstat(fd, &st) < 0)
+    // ② 使用 O_RDONLY 開啟；對檔案/目錄/連結皆可
+    fd = open(path, 0); // 0 = O_RDONLY
+    if (fd < 0)
     {
-        fprintf(2, "ls: cannot stat %s\n", path);
-        close(fd);
+        fprintf(2, "ls: cannot open %s\n", path);
         return;
     }
 
     switch (st.type)
     {
+    // ---------- 普通檔案 ----------
     case T_FILE:
-        printf("%s %d %d %l\n", fmtname(path), st.type, st.ino, st.size);
+    {
+        char perm[3];
+        perm[0] = (st.mode & M_READ) ? 'r' : '-';
+        perm[1] = (st.mode & M_WRITE) ? 'w' : '-';
+        perm[2] = '\0';
+        printf("%s %d %d %d %s\n", fmtname(path), st.type, st.ino, st.size,
+               perm);
         break;
+    }
 
+    // ---------- 目錄 ----------
     case T_DIR:
-        if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf)
+    {
+        if (strlen(path) + 1 + DIRSIZ + 1 > sizeof(buf))
         {
             printf("ls: path too long\n");
             break;
@@ -57,35 +83,98 @@
         strcpy(buf, path);
         p = buf + strlen(buf);
         *p++ = '/';
+
         while (read(fd, &de, sizeof(de)) == sizeof(de))
         {
             if (de.inum == 0)
                 continue;
             memmove(p, de.name, DIRSIZ);
             p[DIRSIZ] = 0;
-            if (stat(buf, &st) < 0)
+
+            struct stat est;
+            if (stat(buf, &est) < 0)
             {
                 printf("ls: cannot stat %s\n", buf);
                 continue;
             }
-            printf("%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
+
+            char perm[3];
+            perm[0] = (est.mode & M_READ) ? 'r' : '-';
+            perm[1] = (est.mode & M_WRITE) ? 'w' : '-';
+            perm[2] = '\0';
+
+            printf("%s %d %d %d %s\n", fmtname(buf), est.type, est.ino,
+                   est.size, perm);
         }
         break;
     }
 
+    // ---------- 符號連結 ----------
+    case T_SYMLINK:
+    {
+        char target[MAXPATH];
+        safestrcpy(target, path, sizeof(target));
+
+        struct stat tst;
+
+        // 解析連結鍊直到不是 symlink 為止
+        while (1)
+        {
+            int lfd = open(target, O_NOACCESS); // 不跟隨
+            if (lfd < 0)
+            {
+                fprintf(2, "ls: cannot open %s\n", target);
+                break;
+            }
+            if (fstat(lfd, &tst) < 0)
+            {
+                fprintf(2, "ls: cannot stat %s\n", target);
+                close(lfd);
+                break;
+            }
+            if (tst.type != T_SYMLINK)
+            {
+                close(lfd);
+                break; // 得到最終 target metadata
+            }
+            int n = read(lfd, target, MAXPATH - 1);
+            close(lfd);
+            if (n < 0)
+            {
+                fprintf(2, "ls: cannot read %s\n", target);
+                break;
+            }
+            target[n] = '\0';
+        }
+
+        if (tst.type == T_DIR)
+        {
+            // link 指向目錄 → 顯示目錄內容
+            ls(target);
+        }
+        else
+        {
+            // link 指向檔案或無效 → 列印 link 本身資訊
+            char perm[3] = "rw"; // symlink 本身固定 rw
+            printf("%s %d %d %d %s\n", fmtname(path), T_SYMLINK, st.ino,
+                   st.size, perm);
+        }
+        break;
+    }
+    } // end switch
+
     close(fd);
 }
 
+// ───── main ────────────────────────────────────────────────────────────
 int main(int argc, char *argv[])
 {
-    int i;
-
     if (argc < 2)
     {
         ls(".");
         exit(0);
     }
-    for (i = 1; i < argc; i++)
+    for (int i = 1; i < argc; i++)
         ls(argv[i]);
     exit(0);
 }
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/user/ulib.c mp4-new/user/ulib.c
--- mp4/user/ulib.c	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/user/ulib.c	2025-05-22 19:20:12.123302500 +0800
@@ -71,7 +71,7 @@
     int fd;
     int r;
 
-    fd = open(n, O_RDONLY);
+    fd = open(n, O_NOACCESS);
     if (fd < 0)
         return -1;
     r = fstat(fd, st);
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/user/user.h mp4-new/user/user.h
--- mp4/user/user.h	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/user/user.h	2025-05-22 19:20:12.247220700 +0800
@@ -25,7 +25,7 @@
 int uptime(void);
 /* TODO: Access Control & Symbolic Link */
 int symlink(const char *, const char *);
-
+int chmod(int mode_op, const char *path);
 int force_fail(int pbn);
 int get_force_fail(void);
 int raw_read(int pbn, char *buf);
diff -ruN '--exclude=.git' '--exclude=.vscode' mp4/user/usys.pl mp4-new/user/usys.pl
--- mp4/user/usys.pl	2025-05-16 03:36:55.000000000 +0800
+++ mp4-new/user/usys.pl	2025-05-22 19:20:12.010779000 +0800
@@ -45,3 +45,4 @@
 entry("force_disk_fail");
 # TODO: Access Control
 entry("symlink");
+entry("chmod");
